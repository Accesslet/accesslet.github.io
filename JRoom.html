<!DOCTYPE html>
<html>
<head>
  <title>WebRTC Room with Canvas + Chat</title>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    textarea { width: 100%; height: 100px; font-family: monospace; }
    canvas { border: 1px solid black; display: block; margin-top: 10px; }
    .hidden { display: none; }
    #chat { margin-top: 20px; }
  </style>
</head>
<body>

<!-- 🧭 Landing UI: Prompt name & role -->
<div id="landing">
  <h2>WebRTC Multiplayer</h2>
  <input id="nameInput" placeholder="Your Name" />
  <br><br>
  <button onclick="start('host')">Create Room</button>
  <button onclick="start('guest')">Join Room</button>
</div>

<!-- 📡 Session UI (hidden until role is picked) -->
<div id="session" class="hidden">
  <h3 id="roleLabel"></h3>

  <div id="hostArea" class="hidden">
    <label>Host → Share this SDP:</label>
    <textarea id="localOffer" readonly></textarea>
    <label>Paste guest’s answer here:</label>
    <textarea id="remoteAnswer"></textarea>
    <button onclick="setRemoteAnswer()">Connect</button>
  </div>

  <div id="guestArea" class="hidden">
    <label>Guest → Paste host’s offer:</label>
    <textarea id="remoteOffer"></textarea>
    <button onclick="setRemoteOffer()">Set Offer</button>
    <button onclick="createAnswer()">Create Answer</button>
    <label>Your answer (send to host):</label>
    <textarea id="localAnswer" readonly></textarea>
  </div>

  <!-- 🎮 Canvas area -->
  <canvas id="canvas" width="600" height="400"></canvas>

  <!-- 💬 Chat UI -->
  <div id="chat">
    <h3>Chat</h3>
    <div id="chatLog" style="border:1px solid #ccc; height:100px; overflow:auto; padding:5px;"></div>
    <input id="chatInput" style="width: 80%;" placeholder="Say something..." />
    <button onclick="sendChat()">Send</button>
  </div>
</div>

<script>
let pc, channel;
let role = "";
let myName = "";
let myId = crypto.randomUUID();

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const peers = {};
const dotSize = 15;

const myDot = {
  id: myId,
  name: "",
  x: Math.random() * canvas.width,
  y: Math.random() * canvas.height,
  tx: 0,
  ty: 0,
  color: '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0')
};
myDot.tx = myDot.x;
myDot.ty = myDot.y;
peers[myId] = myDot;

// 🧭 Step 1: Choose name and role
function start(selectedRole) {
  myName = document.getElementById("nameInput").value.trim() || "Player";
  myDot.name = myName;
  role = selectedRole;

  document.getElementById("landing").classList.add("hidden");
  document.getElementById("session").classList.remove("hidden");
  document.getElementById("roleLabel").innerText = `You are the ${role}`;

  setupConnection();

  if (role === "host") {
    document.getElementById("hostArea").classList.remove("hidden");
    createOffer();
  } else {
    document.getElementById("guestArea").classList.remove("hidden");
  }
}

// 🎥 Setup WebRTC and listeners
function setupConnection() {
  pc = new RTCPeerConnection({
    iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
  });

  pc.onicecandidate = e => {
    if (!e.candidate) {
      // Send SDP only when gathering is complete
      if (role === "host") {
        document.getElementById("localOffer").value = JSON.stringify(pc.localDescription);
      } else {
        document.getElementById("localAnswer").value = JSON.stringify(pc.localDescription);
      }
    }
  };

  pc.ondatachannel = e => setupChannel(e.channel);
}

// 🧠 Data channel message handler
function setupChannel(dc) {
  channel = dc;
  channel.onopen = () => send({ type: "hello", dot: myDot });
  channel.onmessage = (e) => {
    const msg = JSON.parse(e.data);
    if (msg.type === "hello") {
      msg.dot.tx = msg.dot.x;
      msg.dot.ty = msg.dot.y;
      peers[msg.dot.id] = msg.dot;
      send({ type: "hello", dot: myDot });
    } else if (msg.type === "move") {
      if (peers[msg.id]) {
        peers[msg.id].tx = msg.tx;
        peers[msg.id].ty = msg.ty;
      }
    } else if (msg.type === "chat") {
      writeChat(`${msg.name}: ${msg.text}`);
    } else if (msg.type === "bye") {
      delete peers[msg.id];
    }
  };
}

// 📡 Host: create offer & data channel
function createOffer() {
  const dc = pc.createDataChannel("chat");
  setupChannel(dc);
  pc.createOffer().then(o => pc.setLocalDescription(o));
}

// 📥 Host: paste guest answer
function setRemoteAnswer() {
  const sdp = JSON.parse(document.getElementById("remoteAnswer").value);
  pc.setRemoteDescription(new RTCSessionDescription(sdp));
}

// 📥 Guest: paste host offer
function setRemoteOffer() {
  const sdp = JSON.parse(document.getElementById("remoteOffer").value);
  pc.setRemoteDescription(new RTCSessionDescription(sdp));
}

// 🔄 Guest: create answer
function createAnswer() {
  pc.createAnswer().then(a => pc.setLocalDescription(a));
}

// 💬 Send a chat message
function sendChat() {
  const input = document.getElementById("chatInput");
  const text = input.value.trim();
  if (!text) return;
  writeChat("You: " + text);
  send({ type: "chat", name: myName, text });
  input.value = "";
}

// 🖋️ Append chat to log
function writeChat(msg) {
  const log = document.getElementById("chatLog");
  const div = document.createElement("div");
  div.textContent = msg;
  log.appendChild(div);
  log.scrollTop = log.scrollHeight;
}

// 🎯 Movement: click to move your square
canvas.addEventListener("click", (e) => {
  const rect = canvas.getBoundingClientRect();
  const tx = e.clientX - rect.left;
  const ty = e.clientY - rect.top;
  myDot.tx = tx;
  myDot.ty = ty;
  send({ type: "move", id: myId, tx, ty });
});

// 🔁 Send data if ready
function send(obj) {
  if (channel && channel.readyState === "open") {
    channel.send(JSON.stringify(obj));
  }
}

// 🎬 Animation loop for drawing players
function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (const id in peers) {
    const dot = peers[id];
    dot.x += (dot.tx - dot.x) * 0.1;
    dot.y += (dot.ty - dot.y) * 0.1;
    ctx.fillStyle = dot.color;
    ctx.fillRect(dot.x, dot.y, dotSize, dotSize);
    ctx.fillText(dot.name, dot.x + 20, dot.y + 12);
  }
  requestAnimationFrame(animate);
}
animate();

// 👋 Send disconnect notice
window.addEventListener("beforeunload", () => {
  send({ type: "bye", id: myId });
});
</script>
</body>
</html>
